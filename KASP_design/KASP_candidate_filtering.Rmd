---
title: "KASP candidate filtering"
author: "Seren Villwock"
date: "2/10/2021"
output: html_document
---

Read in the candidateregion.stats.csv file (edited from candidateregion.stats.txt to include the SNP column with candidate names)
```{r}
library(stringr)
library(tidyr)
library(dplyr)
library(ggplot2)

setwd("/Users/serenwork/Desktop/Research/Glaziovii_introgression/KASP_design")
snp.stats <- read.csv("candidateregion.stats.csv")
```


Fix range overlap issue:
```{r}
snp.stats.overlap <- snp.stats[!is.na(snp.stats$Range.overlap),] #select positions where there is a secondary range.overlap candidate
rownames(snp.stats.overlap) <- 1:nrow(snp.stats.overlap)

snp.stats.overlap.sep <- separate(data=snp.stats.overlap, col=Candidate, into=c("cand2", "cand1"), sep=",")
#cand2 is the overlap candidate (associated with Range.overlap) #cand1 is associated with Range



#Prepare cand2 to merge
snp.stats.overlap.cand2 <- snp.stats.overlap.sep
snp.stats.overlap.cand2 <- subset(snp.stats.overlap.cand2, select = -c(cand1,Range) )
snp.stats.overlap.cand2$true.cand <- snp.stats.overlap.cand2$cand2 #here true.cand is the overlap candidate
snp.stats.overlap.cand2$Range <- snp.stats.overlap.cand2$Range.overlap #now Range is referring to the overlap candidate


#Prepare original dataframe to merge
candidates.split <- separate(data=snp.stats, col=Candidate, into=c("cand2", "cand1"), sep=",")
candidates.split$true.cand <- NA

candidates.split$true.cand <- ifelse(is.na(candidates.split$Range.overlap), candidates.split$cand2, candidates.split$cand1)
#candidates.split is only keeping data for cand1


#Merge rows associated with the first and second candidates
snp.stats.reslv <- bind_rows(candidates.split, snp.stats.overlap.cand2)

snp.stats.reslv <- snp.stats.reslv %>% select(4:ncol(snp.stats.reslv))
snp.stats.reslv <- snp.stats.reslv[,c(ncol(snp.stats.reslv),1:(ncol(snp.stats.reslv)-1))]

snp.stats <- snp.stats.reslv
```





Alternate method of calculating DP that avoids the AD comma issue:
```{r}
# Calculate DP for glaz & hets (all samples)
colnums <- seq(from=10, to=99, by=3)
snp.stats$DP_SUM <- rowSums(snp.stats[,colnums])

# Calculate DP just for glaz samples
glazcolnums <- seq(from=10, to=22, by=3)
snp.stats$DP_SUM_glaz <- rowSums(snp.stats[,glazcolnums])

```

Copy df for 150bp region
```{r}
snp.stats.150 <- snp.stats
```


Select 100bp region (out of 150)
```{r}
snp.stats <- snp.stats[which(snp.stats$Range <= 50 & snp.stats$Range >= -50),]
```




Grep each candidate, take average AD in +/- 50 bp range
```{r}
candidates <- read.table("~/Desktop/Research/Glaziovii_introgression/KASP_design/candidates0128.txt")
candidates <- candidates$V1



candidate.summary <- data.frame()

for (i in 1:length(candidates))
{
DP_SUMs_i <- snp.stats$DP_SUM[grepl(candidates[i], snp.stats$true.cand)]
mean_i <- mean(DP_SUMs_i)
min_i <- min(DP_SUMs_i)
max_i <- max(DP_SUMs_i)


DP_SUMs_g <- snp.stats$DP_SUM_glaz[grepl(candidates[i], snp.stats$true.cand)]
mean_g <- mean(DP_SUMs_g)
min_g <- min(DP_SUMs_g)
max_g <- max(DP_SUMs_g)


candidate.summary <- rbind(candidate.summary, c(candidates[i], mean_i, min_i, max_i, mean_g, min_g, max_g))
}

names(candidate.summary) <- c("candidate", "meanDP", "minDP", "maxDP", "meanglazDP", "minglazDP", "maxglazDP")

```



Visualize summary stats to decide cutoffs
```{r}
# Mean DP
hist(candidate.summary$meanDP, main = "mean DP in 100bp region around candidate SNP")
abline(v=400,col="red") #draw line for cutoff

# Minimum DP
hist(candidate.summary$minDP, main = "minimum DP in 100bp region around candidate SNP")
abline(v=100,col="red") #draw line for cutoff


# Maximum DP - could be artificially high depth in repeat regions which we want to avoid
hist(candidate.summary$maxDP, main = "maximum DP in 100bp region around candidate SNP")
abline(v=400,col="red") #draw line for cutoff

# Mean glaz DP
hist(candidate.summary$meanglazDP, main = "mean DP of glaziovii samples in 100bp region around candidate SNP", xlim = range(c(0,25,50,75,100,125,150, 175, 190)))
abline(v=100,col="red") #draw line for cutoff

# Min glaz DP
hist(candidate.summary$minglazDP, main = "min DP of glaziovii samples in 100bp region around candidate SNP")
abline(v=10,col="red") #draw line for cutoff

# Max glaz DP
hist(candidate.summary$maxglazDP, main = "max DP of glaziovii samples in 100bp region around candidate SNP")
abline(v=80,col="red") #draw line for cutoff


```

MeanDP looks pretty good across the board (and it should because filters were already applied).

Set DP cutoffs for different categories:
```{r}
minDPcut <- 100
maxDPcut <- 400
meanDPlowcut <- 250
meanDPupcut <- 400
meanglazDPcut <- 70
minglazDPcut <- 10
maxglazDPcut <- 80


top.DP.candidates <- candidate.summary[which(
  candidate.summary$minDP > minDPcut & 
    candidate.summary$maxDP < maxDPcut & 
    candidate.summary$meanDP > meanDPlowcut &
    candidate.summary$meanDP < meanDPupcut &
    candidate.summary$meanglazDP < meanglazDPcut &
    candidate.summary$minglazDP > minglazDPcut &
    candidate.summary$maxglazDP < maxglazDPcut
    ),]


# Visualize top DP candidates
hist(top.DP.candidates$meanDP, main = "mean DP across all samples\nat sites in 100bp region around candidate SNP")
hist(top.DP.candidates$meanglazDP, main= "mean DP across glaz samples\nat sites in 100bp region around candidate SNP")
```


# Filter by conserved site proximity.
Load in conserved site list:
```{r}
conserved <- read.table("~/Desktop/Research/Glaziovii_introgression/KASP_design/conservedsites0128.txt")
conserved <- conserved$V1
```

Calculate the number of conserved sites contained in the 100bp around the candidate regions
```{r}
conserved.summary <- data.frame()

for (i in 1:length(candidates))
{
pos_range_i <- snp.stats$POS[grepl(candidates[i], snp.stats$true.cand)]
cons_count_i <- length(intersect(pos_range_i, conserved))

conserved.summary <- rbind(conserved.summary, c(candidates[i], cons_count_i))
}
names(conserved.summary) <- c("candidate", "conserved.count")
```


Visualize conserved site summary:
```{r}
hist(conserved.summary$conserved.count, main = "number of nonvariant sites\nin 100bp region around candidate SNP")
```


```{r}
top.conserved <- slice_max(conserved.summary, order_by=conserved.count, n=40)

top.candidates <- intersect(top.conserved$candidate, top.DP.candidates$candidate)

#edited 3/9 to add the next-best candidate 36155769 to replace 36159781 which failed KASP primer design

top.candidates[39] <- "36155769"
top.candidates <- as.numeric(top.candidates)


#write.table(top.candidates, "top38candidateslist.txt", sep = "\n", col.names = FALSE, row.names = FALSE)

#write.table(top.conserved, "top38candidates_conservedsummary.csv", sep=",",col.names=TRUE, row.names= FALSE)

```




Visualize distribution of candidates:
```{r}
top.candidates.graph <- data.frame(x=top.candidates, y=top.candidates+1)

ggplot(data=top.candidates.graph) +
  geom_segment(aes(x=x, xend=(x+1), y=0, yend=1), color="steelblue", size=0.75) +
  scale_y_continuous(labels=NULL) +
  ggtitle("Distribution of top 38 KASP candidates")

#ggsave("top.candidates.distribtion.graph.jpg",
  plot = last_plot(),
  width = 7,
  height = 2,
  units = "in")

#KASP primer ranges - this doesn't show much because the range is so small.
ggplot(data=top.candidates.graph) +
  geom_segment(aes(x=(x-50), xend=(x+50), y=0, yend=1), color="steelblue", size=0.5) +
  scale_y_continuous(labels=NULL) +
  ggtitle("Distribution of top 38 KASP candidates")
```



Look at larger regions just around top 38 candidates:

```{r}
library(seqinr)

snp.stats.150$true.cand <- as.character(snp.stats.150$true.cand)
top.candidates <- as.character(top.candidates)
top.snp.stats <- snp.stats.150[which(grepl(paste(top.candidates, collapse="|"), snp.stats.150$true.cand)),]



#Initiate columns for IUPAC consensus sequences
top.snp.stats$seq <- NA
top.snp.stats$IUPAC <- NA
top.snp.stats$problem <- NA

#Flag indels - will fix these manually
top.snp.stats$problem[which(nchar(top.snp.stats$REF) != 1)] <- "y"


#remove commas from ALT string so multiple alt alleles get included in IUPAC
top.snp.stats$ALT_collapse <- sub(pattern=",", replacement="", x=top.snp.stats$ALT)



for (i in 1:nrow(top.snp.stats)) {
  if (top.snp.stats[i, "ALT"] != '.') {
    
    #wherever there is an alt allele, paste the ref & alt alleles together in the seq column
  top.snp.stats[i, "seq"] <- paste(c(top.snp.stats[i, "REF"], top.snp.stats[i, "ALT_collapse"]), collapse="") 
  
  #if there is no alt allele, just put the ref allele in the seq column
  } else {
  top.snp.stats[i, "seq"] <- top.snp.stats[i, "REF"]
  } 
  
  # make a consensus sequence with bma()  
  top.snp.stats$IUPAC[i] <- bma(unlist(strsplit(top.snp.stats$seq[i], split="")))
  
  
  
}



#capitalize the consensus
top.snp.stats$IUPAC <- toupper(top.snp.stats$IUPAC)

#add a bracket around the candidate SNP
top.snp.stats$IUPAC <- with(top.snp.stats, ifelse(!is.na(top.snp.stats$SNP_POS), paste0("[", IUPAC, "]"), IUPAC))

#fix and flag the indel sites
top.snp.stats$IUPAC <-with(top.snp.stats, ifelse(nchar(top.snp.stats$REF) != 1 , paste0("*(", REF, ")"), IUPAC))






#lowercase for low quality sites
top.snp.stats$IUPAC <- with(top.snp.stats, ifelse(top.snp.stats$DP_SUM_glaz < 30 | top.snp.stats$DP_SUM < 225, tolower(IUPAC), IUPAC))






write.csv(top.snp.stats, "top.snp.stats.IUPAC.updated.csv")
```



Print concatenate sequences to txt and csv files:
```{r}
consensus_seqlist = list() # initiate list

for (i in 1:length(top.candidates)) {
  
  this.cand.name <- top.candidates[i]
  
  this.cand  <- top.snp.stats[which(grepl(top.candidates[i],
                                top.snp.stats$true.cand)),]
  
    this.cand <- this.cand[,c(1:6,101:102)]
    

    
    this.cand.df <- data.frame("POS"=this.cand$POS, 
                               "Range"=this.cand$Range,
                               "REF"=this.cand$REF, 
                               "ALT"=this.cand$ALT,
                               "seq" = this.cand$seq,
                               "IUPAC" = this.cand$IUPAC)
    
    

    
    consensus.seq <- paste(this.cand.df$IUPAC, collapse="")
    
    consensus_seqlist[[i]] <- consensus.seq # add it to the main list
  
    names(consensus_seqlist[[i]]) <- top.candidates[i]
}


folder <- "candidate_consensus_seqs/"
all.cand.seq.df <- data.frame(matrix(ncol = 2, nrow = 38))
names(all.cand.seq.df) <- c("candidate","consensus")


for (i in 1:length(consensus_seqlist)) {
  
#filepath <- paste(folder, names(consensus_seqlist[[i]]), '.txt', sep="")
#write.table(consensus_seqlist[[i]], filepath, sep="\n")
  
  all.cand.seq.df[i,2] <- consensus_seqlist[[i]]
  all.cand.seq.df[i,1] <- names(consensus_seqlist[[i]])
  
  
}


write.csv(all.cand.seq.df, "topcandidate.consensus.updated.csv")


```


print REF/ALT list
```{r}
REF.ALT.list <- top.snp.stats[top.snp.stats$Range== 0, 1:6] 
write.csv(REF.ALT.list, "ref.alt.list.updated.csv")
```











OLD CODE - IGNORE BELOW




summarize where the conserved sites are in relation to the candidate
```{r}
top.snp.stats$conserved <- NA

top.snp.stats$conserved[which(top.snp.stats$POS %in% conserved)] <- "cons"
top.snp.stats$conserved[which(is.na(top.snp.stats$conserved))] <- "snp"




conserved.dist.summary <- data.frame("candidate"=top.candidates,"other.snps"=NA)

for (i in 1:length(top.candidates))
{
other.snps.list  <- list(top.snp.stats$Range[which(top.snp.stats$conserved =="snp" & top.snp.stats$true.cand == top.candidates[i])])

conserved.dist.summary$candidate[i] <- top.candidates[i]
conserved.dist.summary$other.snps[i] <- other.snps.list
  
}

names(conserved.dist.summary) <- c("candidate", "other.snps")


#top.snp.stats$Range[which(top.snp.stats$conserved =="snp")]

```




Old
Export sequence lists:
```{r, eval=FALSE}
candidate_seqlist = list() # initiate list

for (i in 1:length(top.candidates)) {
  
  this.cand.name <- top.candidates[i]
  
  this.cand  <- top.snp.stats[which(grepl(top.candidates[i],
                                            top.snp.stats$true.cand)),]
    this.cand <- this.cand[,1:6]
    
    this.cand.df <- data.frame("POS"=this.cand$POS, 
                               "REF"=this.cand$REF, 
                               "ALT"=this.cand$ALT)
    
    this.cand.df.t <- data.frame(t(this.cand.df))
    
    this.cand.df.t$candidate <- this.cand.name

    candidate_seqlist[[i]] <- this.cand.df.t # add it to the main list
  
    
}


all_candidate_seqs <- do.call(rbind, candidate_seqlist)

#write.csv(all_candidate_seqs, file="all_candidate_seqs_150.csv")



```



Fix comma issue AD column and separate into REF and ALT:
(can fix this problem in the future when the file is written out )
```{r}

#snp.stats$AD <- str_replace(snp.stats$AD, ",(.+,)",  "\\1")

### fixing the multiple ALT allele problem
## check in three ALT allele case:
#str_replace(snp.stats[12402:12410,8], "(^[0-9]),(.+,)",  "\\1\\2")

## fix for 2 ALT allele case:
#snp.stats$AD <- str_replace(snp.stats$AD, "(^[0-9]),(.+,)",  "\\1\\2") 

#snp.stats <- separate(snp.stats, col=AD, into=c("AD_REF", "AD_ALT", "AD_ALT2") , sep=",")
#snp.stats$AD_ALT <- as.numeric(snp.stats$AD_ALT)
#snp.stats$AD_REF <- as.numeric(snp.stats$AD_REF)
#snp.stats$AD_ALT2 <- as.numeric(snp.stats$AD_ALT2)

#snp.stats$AD_ALT[is.na(snp.stats$AD_ALT)] <- 0
#snp.stats$AD_ALT2[is.na(snp.stats$AD_ALT2)] <- 0

#snp.stats$AD_SUM <- snp.stats$AD_REF + snp.stats$AD_ALT + snp.stats$AD_ALT2

```

Old for loop:
```{r}

  #top.candidates.seq <- data.frame()

#for (i in 1:length(top.candidates))
{
#this.cand  <- top.snp.stats[which(grepl(top.candidates[i], top.snp.stats$true.cand)),]
#this.cand <- this.cand[,1:6]
#this.cand.df <- data.frame("POS"=this.cand$POS, "REF"=this.cand$REF, "ALT"=this.cand$ALT)
#this.cand.df.t <- data.frame(t(this.cand.df))
#this.cand.name <- top.candidates[i]
#this.cand.df.t$candidate <- this.cand.name
#filename <- paste(this.cand.name, "seq.csv", sep="_")
#write.table(this.cand.df.t, filename, sep = ",", col.names = FALSE, row.names = TRUE)
#top.candidates.seq <- rbind(top.candidates.seq, this.cand.df.t)
}

```

